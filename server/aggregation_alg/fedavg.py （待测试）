class fedavgAggregator(ServerAggregator):
    def __init__(self):
        super().__init__()
    
    def _aggregate_alg(self, raw_client_model_or_grad_list):
        num_clients = len(raw_client_model_or_grad_list)
        aggregated_weights = None
        
        for raw_client_model_or_grad in raw_client_model_or_grad_list:
            if aggregated_weights is None:
                # Initialize aggregated weights with the first client's model or gradient
                aggregated_weights = raw_client_model_or_grad
            else:
                # Aggregate the client's model or gradient with the current aggregated weights
                for layer_idx in range(len(aggregated_weights)):
                    aggregated_weights[layer_idx] += raw_client_model_or_grad[layer_idx]
        
        # Divide the aggregated weights by the number of clients to get the federated average
        for layer_idx in range(len(aggregated_weights)):
            aggregated_weights[layer_idx] /= num_clients
        
        return aggregated_weights
    
    
if __name__ == '__main__':
    # Unit test
    # Create 3 clients with different initial weights
    client1_weights = [np.array([1, 2, 3]), np.array([4, 5, 6])]
    client2_weights = [np.array([2, 3, 4]), np.array([5, 6, 7])]
    client3_weights = [np.array([3, 4, 5]), np.array([6, 7, 8])]
    
    # Aggregate the clients' weights using the fedavg aggregator
    aggregator = fedavgAggregator()
    aggregated_weights = aggregator.aggregate([client1_weights, client2_weights, client3_weights])
    
    # Check that the aggregated weights are the expected federated average
    expected_weights = [np.array([2, 3, 4]), np.array([5, 6, 7])]
    assert np.allclose(aggregated_weights, expected_weights)
    
    print("Unit test passed!")
